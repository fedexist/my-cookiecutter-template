pipeline {
    agent any

    environment {
        CREDENTIALS_ID = "${PROJECT_ID}-json"
        GCR_URL = "eu.gcr.io/${PROJECT_ID}"
        COMMIT_HASH = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
        BASE_IMAGE = "{{cookiecutter.project_slug}}"
        BASE_IMAGE_NAME = "${env.GCR_URL}/${env.BASE_IMAGE}"
        COMMIT_TAG = sh(script: "echo ${GIT_BRANCH} | sed -r 's/[_/.?]+/-/g' | awk '{print tolower(\$0)}' | xargs -I@ echo @-${env.COMMIT_HASH}-${env.BUILD_NUMBER}", returnStdout: true).trim()
        PYTHON_INTERPRETER = 'python{{ cookiecutter.python_version }}'
        PYTHON_VERSION = '{{ cookiecutter.python_version }}'
        PACKAGE_VERSION = sh(script: "python3 setup.py --version", returnStdout: true).trim()
        DOCKER_VERSION = sh(script: "echo ${PACKAGE_VERSION} | tr + .", returnStdout: true).trim()
        PYPI_REPO_STAGING = "http://pypi.advancedanalytics.generali.com/ge-it-aa/staging/"
        PYPI_REPO_STABLE = "http://pypi.advancedanalytics.generali.com/ge-it-aa/stable/"
        CONFLUENCE_TOKEN = credentials('confluence-token')
        HOME="${env.WORKSPACE}"
    }

    stages {

        stage('Clone sources') {
            steps {
                slackSend (color: '#FFFF00', message: "STARTED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})")
                sh """
                echo ${env.BRANCH_NAME}
                echo ${env.TAG_NAME}
                """
                git branch: env.gitlabSourceBranch, poll: false, credentialsId: '2bd6f462-e60e-4de9-a67c-da11e3829363', url: env.gitlabSourceRepoHttpUrl

                script {
                    withCredentials([file(credentialsId: env.CREDENTIALS_ID, variable: "GC_KEY")]) {
                        sh("gcloud auth activate-service-account --key-file=${GC_KEY}")
                        sh("gcloud auth configure-docker")
                    }
                }
            }
        }

       stage("Env Config") {
            steps {
                script {
                    // load configs
                    load "cicd/${BRANCH_TYPE}.groovy"
                    echo "Deploy Settings: Env = ${env.ENV}, TargetProjectId = ${env.TARGET_PROJECT}, BranchType = ${env.BRANCH_TYPE}, DockerTag = ${env.COMMIT_TAG}"
                    // set build name
                    currentBuild.displayName = "Build: [#${BUILD_NUMBER}] - Env: ${env.ENV}"
                    currentBuild.description = "Env: ${env.ENV}\nBranchType = ${env.BRANCH_TYPE}\nTarget: ${env.TARGET_PROJECT}\nDockerTag: ${env.COMMIT_TAG}"
                }
            }
        }

        stage('Run tests') {

            agent {
                docker {
                    image "eu.gcr.io/${env.ARTIFACT_PROJECT}/aa-python:${PYTHON_VERSION}-slim"
                    reuseNode true
                    label '{{ cookiecutter.legal_entity.lower() }}'
                }
            }
            steps {
                sh '''
                pip install -r requirements_dev.txt
                tox
                '''
            }
        }

        stage('SQ analysis') {

           agent {
                docker {
                    image "sonarsource/sonar-scanner-cli"
                    reuseNode true
                    label '{{ cookiecutter.legal_entity.lower() }}'
                }
            }
            environment {
                scannerHome = tool 'sonar_scanner'
            }
            steps {
                withSonarQubeEnv(credentialsId: 'sonarqube_token', installationName: 'sonarqube_aa') {
                    sh '${scannerHome}/bin/sonar-scanner'
                }
            }
        }


        stage('Staging on PyPi') {
            agent {
                docker {
                    image "eu.gcr.io/${env.ARTIFACT_PROJECT}/aa-python:${PYTHON_VERSION}-slim"
                    reuseNode true
                    label '{{ cookiecutter.legal_entity.lower() }}'
                }
            }
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'pypi-credentials', usernameVariable: 'PYPI_USERNAME', passwordVariable: 'PYPI_PASSWORD')]) {
                        sh """
                        make staging
                        """
                    }
                }
            }
        }

        stage('Generate and publish doc staging') {
            agent {
                docker {
                    image "eu.gcr.io/${env.ARTIFACT_PROJECT}/aa-python:${PYTHON_VERSION}-slim"
                    reuseNode true
                    label '{{ cookiecutter.legal_entity.lower() }}'
                }
            }
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'pypi-credentials', usernameVariable: 'PYPI_USERNAME', passwordVariable: 'PYPI_PASSWORD')]) {
                        sh """
                        pip install .
                        pip install devpi-client
                        make docs
                        cd docs
                        cd _build/html && zip -r {{cookiecutter.package_name}}-${version}.doc.zip . && cd -
                        devpi use ${PYPI_REPO_STAGING}
                        devpi login ${PYPI_USERNAME} --password=${PYPI_PASSWORD}
                        devpi upload _build/html/{{cookiecutter.package_name}}-${version}.doc.zip
                        """
                    }
                }
            }

        }

{% if cookiecutter.use_docker == 'y' %}

        stage('Build, Push & Deploy Infra'){
            environment {
                TARGET_PROJECT_OWNER_CREDENTIALS_ID = getCredentialsId(env.TARGET_PROJECT_ID)
            }
            agent {
                docker {
                    image "eu.gcr.io/${env.ARTIFACT_PROJECT}/aa-terraform:1.0"
                    reuseNode true
                    args '-u root:root --entrypoint= -v /var/run/docker.sock:/var/run/docker.sock'
                    label '{{ cookiecutter.legal_entity.lower() }}'
                }
            }
            steps {
                withCredentials([
                    file(credentialsId: env.TERRAFORM_SA_CRED_NAME, variable: "GOOGLE_APPLICATION_CREDENTIALS"),
                    file(credentialsId: env.TARGET_PROJECT_OWNER_CREDENTIALS_ID, variable: "DOCKER_APPLICATION_CREDENTIALS")
                ]) {
                    script {

                        sh """
                            terraform -chdir=\$(pwd)/tf init \
                                -no-color \
                                -compact-warnings \
                                -backend-config=bucket=${env.STATE_BUCKET}
                        """
                        sh """
                            terraform -chdir=\$(pwd)/tf apply \
                                -auto-approve \
                                -no-color \
                                -compact-warnings \
                                -var-file=env/${env.ENV}.tfvars \
                                -var=gcr_target_project=${env.TARGET_PROJECT_ID} \
                                -var=gcp_sa_key=${DOCKER_APPLICATION_CREDENTIALS} \
                                -var='image_tags=["latest","${DOCKER_VERSION}","${COMMIT_TAG}"]' \
                                -var=build_args=PACKAGE_VERSION=${PACKAGE_VERSION}
                        """
                    }
                }
            }
        }
    }

{% endif %}

        stage('Release on PyPi') {
           agent {
                docker {
                    image "eu.gcr.io/${env.ARTIFACT_PROJECT}/aa-python:${PYTHON_VERSION}-slim"
                    reuseNode true
                    label '{{ cookiecutter.legal_entity.lower() }}'
                }
            }

            when {
                allOf {
                    expression {
                        return env.GIT_BRANCH == "origin/master"
                    }

                    expression {
                        return sh(returnStdout: true, script: "git tag --contains").trim()
                    }

                }
            }

            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'pypi-credentials', usernameVariable: 'PYPI_USERNAME', passwordVariable: 'PYPI_PASSWORD')]) {
                        sh """
                        make release
                        """
                    }
                }
            }

        }

        stage('Generate and publish doc release') {
           agent {
                docker {
                    image "eu.gcr.io/${env.ARTIFACT_PROJECT}/aa-python:${PYTHON_VERSION}-slim"
                    reuseNode true
                    label '{{ cookiecutter.legal_entity.lower() }}'
                }
            }

           when {
                allOf {
                    expression {
                        return env.GIT_BRANCH == "origin/master"
                    }

                    expression {
                        return sh(returnStdout: true, script: "git tag --contains").trim()
                    }

                }
           }

            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'pypi-credentials', usernameVariable: 'PYPI_USERNAME', passwordVariable: 'PYPI_PASSWORD')]) {

                        sh """
                        pip install .
                        pip install devpi-client
                        make docs-release
                        cd docs
                        cd _build/html && zip -r {{cookiecutter.package_name}}-${version}.doc.zip . && cd -
                        devpi use ${PYPI_REPO_STABLE}
                        devpi login ${PYPI_USERNAME} --password=${PYPI_PASSWORD}
                        devpi upload _build/html/{{cookiecutter.package_name}}-${version}.doc.zip
                        """
                    }
                }
            }

        }

    }

    post {
        always {
            sh "sudo chmod -R 777 ."
            cleanWs deleteDirs: true, disableDeferredWipeout: true, patterns: [[pattern: '', type: 'INCLUDE']]
            script {
                  sh("docker images -a | grep '${env.BASE_IMAGE}' | awk \'{print \$3}\' | xargs --no-run-if-empty docker rmi -f")
            }
        }
        success {
            slackSend (color: '#00FF00', message: "SUCCESSFUL: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})")
        }
        failure {
            slackSend (color: '#FF0000', message: "FAILURE: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})")

        }
    }
}
